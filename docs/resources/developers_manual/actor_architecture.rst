#######################################################################################################################
Python actor - reference architecture and implementation
#######################################################################################################################

.. toctree::

.. _actor_layers_anchor:

Actor layers
#######################################################################################################################

+----------------------------+-------------------------+
| Programming language       |     Layer               |
+============================+=========================+
|                            |  Computational scenario |
|                            |  (aka *workflow*)       |
|                            +-------------------------+
| Workflow language          | Actor                   |
+           (Python)         +-------------------------+
|                            | Binder                  |
+----------------------------+                         |
|Physics model language      |                         |
| (C++, Fortran)             +-------------------------+
|                            | Wrapper                 |
|                            +-------------------------+
+                            | Native code             |
+----------------------------+-------------------------+

Scenario (aka workflow) layer
==========================================================================================

Computing scenario (aka workflow) is a directed graph, built with a set of components (actors) to execute given algorithm.
Python actors built by iWrap can be managed by a Python script provided by *workflow designer/developer*.
Such script:

* Prepares initial data of the workflow (e.g. reads IDSes, that will be processed)
* Creates and initialises all workflow items (actors)
* Executes actors
* Manages passing data between actors
* Finalises all actors
* Saves results of computations

Please, use this link for :ref:`example of workflow implementation <workflow_example_anchor>`.

Actor layer
==========================================================================================

.. note::
   Please note that in this documentation the term ``actor`` usually means the whole component generated by iWrap.
   However in this section this term is limited to describe only its *the highest* layer!

The *actor layer* (implemented as Python class derived from abstract class ``Actor``)  resides on the top
of the actor stack.
This layer:

* Hides a complexity of underlying layers from the user

* Provides a well defined API, that can be called from workflow, used for:
  * Configuring how given actor will be run
  * Calling methods of the native code provided by the user from system library or binary executable
* Defines an actor logic


.. code-block:: python

 class Actor(ABC):

    @abstractmethod
    def initialize(self, runtime_settings: RuntimeSettings = None, code_parameters: CodeParameters = None) -> None:
        ...

    @abstractmethod
    def run(self, *args)->None:
        ...

    @abstractmethod
    def finalize(self) -> None:
        ...

.. warning::
   The actor layer source code is automatically generated by iWrap and should be not changed by the user.

Binding layer
==========================================================================================

This layer, provides mechanism for 'binding' higher layers, implemented in a workflow programming language (Python) with
lower layers implemented in native code language (CPP/Fortran).

The binding layer, provides low level mechanism for:

* Calling native methods, provided by the user from system library, using Python ``ctypes`` module
* Launching a standalone executable in a separate system process
* Conversion of data (methods arguments) passed from higher layers from Python objects to data understood
  by native code language

**Example of Python ``Binder`` class API**

.. code-block:: python

 class Binder (ABC):

    @abstractmethod
    def initialize(self, actor) -> None:
        ...

    @abstractmethod
    def finalize(self) -> None:
        ...

    @abstractmethod
    def call_init(self, code_parameters: str, sandbox_dir: str, debug_mode=False) -> None:
        ...

    @abstractmethod
    def call_main(self, input_idses, code_parameters:str, sandbox_dir:str) -> None:
        ...

    @abstractmethod
    def call_finish(self, sandbox_dir: str) -> None:
        ...

    @abstractmethod
    def run_standalone(self, ids_list:List[Any], code_parameters:str, exec_command:str, sandbox_dir:str, output_stream) -> None:
        ...

.. warning::
   This component source code is automatically generated by iWrap and should be not changed by the user.

Wrapper layer
==========================================================================================
This layer plays an important role wrapping the native code within system library and standalone executable.
It cooperates also with binding layer in terms of passing and converting data between languages.
Roughly speaking it 'reverts' operations performed by `binder`: while binder converts IDS and other arguments
to a format that can be passed between layers, wrapper 'builds back' IDS objects
(this time in native code language), based on received data. The layer performs also auxiliary operations, converting
data (other than IDS) from the format acceptable by 'language coupling' mechanisms (like e.g. ``ctypes``,
``iso_c_typing``, etc) to a format more friendly to the developer (e.g. conversion of char arrays to strings etc).

.. warning::
   The wrapper source code is automatically generated by iWrap and should be not changed by the user.

Native code layer
==========================================================================================

Native code is an implementation of a physics model, provided by software developer. To be wrapped by iWrap
it needs to have a standardized API (see :ref:`requirements concerning native code API <native_code_api>` for details)

IDS language-to-language conversions
#######################################################################################################################

Currently IMAS handles only, so called, 'legacy' IDS type. Legacy IDSes are very 'huge' and 'deep' tree-like objects,
defined in Data Dictionary and implemented by IMAS Access Layer High Level Interfaces. Unfortunately, there are
no other means of transferring IDSes from a code implemented in one programming language to the code provided
in other language then passing IDS via files.
Two iWrap layers are especially important concerning data conversion and management: binding layer
(implemented in workflow/actor language - Python) and wrapper layer (implemented in native code language - C++/Fortran).

Scenario of transferring IDS from the top (workflow) layer to the lowest (native code) layer:

#. Workflow layer (Python)

   a. IDS object is created/loaded by workflow script

   #. Workflow calls actor method passing IDS object(s) as argument(s)

#. Actor layer (Python)

   a. Actor's method receives IDS object(s)

   #. No operations on IDSes are made (an actor layer is IDS-type agnostic, just passes IDS up and down)

   #. Actor calls binder passing IDS object(s) as argument(s)

#. Binder layer (Python)

   a. Binder receives IDS object(s)

   #. Binder uses temporary IDS storage to save input IDS object(s), obtaining metadata describing IDS(es)

   #. Binder asks IDS storage to prepare a place for putting output IDS(es), obtaining metadata describing IDS(es)

   #. Binder creates objects derived from ``ctypes.Structure`` and puts there IDS metadata

   #. Binder calls wrapper passing IDS metadata object(s) as argument(s) using ``ctypes`` mechanism

#. Wrapper layer (C++/Fortran)

   a. Wrapper receives IDS metadata from binder

   #. Wrapper uses metadata to read IDSes from IMAS AL

   #. Wrapper passes IDS object(s) to native code

.. note::

  * To speed up data transfer, IMAS AL Memory Backend is used where it is possible

  * For easy adoption of other IDS types (HDC, IMASPy)

    * Binder uses generic ``converters``

    * Wrapper uses Jinja2 macros for IDS type specific operations
