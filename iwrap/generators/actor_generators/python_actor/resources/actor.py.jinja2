import os
from typing import Union, List, Any

{%  if code_description.implementation.programming_language %}
from .common.python_actor import PythonActor
{% else %}
from .common.base_actor import ActorBaseClass
{% endif %}

from .common.code_parameters import CodeParameters
from .common.runtime_settings import RuntimeSettings

{%  if code_description.implementation.programming_language %}
class {{actor_description.actor_name}}(PythonActor):
{% else %}
class {{actor_description.actor_name}}(ActorBaseClass):
{% endif %}
    """{{code_description.documentation | wordwrap(width=80, wrapstring='\n\t\t') }}
    """

    def __init__(self):
        super().__init__()
        self.actor_dir = os.path.dirname( os.path.realpath( __file__ ) )

    {%  if not code_description.implementation.programming_language %}
    # {{ "".center(80, '=') }}
    # {{ " ACTOR METHODS TEMPLATES ".center(80, '=') }}
    # {{ "".center(80, '=') }}

    # {{ "".center(80, '-') }}
    # {{ " INITIALIZE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def initialize(self, runtime_settings: RuntimeSettings = None, code_parameters: CodeParameters = None) -> None:
        """
        The method performs initialisation actions

        Args:
            runtime_settings (RuntimeSettings, optional): property tells the actor how native code should
            code_parameters (CodeParameters, optional): physics model parameters
        """
        super().initialize(runtime_settings, code_parameters)
        ...

    # {{ "".center(80, '-') }}
    # {{ " RUN ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def run(self, *args) -> Union[List[Any], Any]:
        """
        The main (aka 'step', 'run') method. Could be called in a loop.
        Args:
            args - a list of input IDSes
        Returns:
            A list of output IDSes
        """
        ...

    # {{ "".center(80, '-') }}
    # {{ " FINALIZE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.remove_sandbox
    @ActorBaseClass.use_sandbox
    def finalize(self) -> None:
        """
        The method is used to perform finalisation actions (clean up the environment etc).
        """
        ...

    # {{ "".center(80, '-') }}
    # {{ " GET_STATE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def get_state(self) -> str:
        """
        A method returning information about internal model state

        Returns:
              An internal state of the code as a string. The iWrap gives a full flexibility to the code developer
              concerning format and content of state description.  It is a kind of a ‘black box’ returned
              from get_state and passed to set_state method during restart, so the only requirement is that
              information returned by get_state is understandable to set_state.

        """
        ...

    # {{ "".center(80, '-') }}
    # {{ " SET_STATE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def set_state(self, state: str) -> None:
        """
        A method restoring internal state of the model.

        Args:
            state (str) -  An internal state of the code as a string returned by a call of `get_state`
        """
        ...

    # {{ "".center(80, '-') }}
    # {{ " GET_TIMESTAMP ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def get_timestamp(self) -> float:
        """
        The method allows to obtain currently computed physical time. Such information can help support consistent
        physical time handling throughout the coupled simulation

        Returns:
            Timestamp: currently computed physical time
        """
        ...


 {%  endif %}