import os, logging
from typing import Union, List, Any

from .common.base_actor import ActorBaseClass

from .common.code_parameters import CodeParameters
from .common.runtime_settings import RuntimeSettings
from .common.runners import Runner

class {{actor_description.actor_name}}(ActorBaseClass):
{%  if code_description.documentation %}
    """{{code_description.documentation | wordwrap(width=80, wrapstring='\n\t\t') }}
    """
{%  endif %}
    # Class logger
    __logger = logging.getLogger(__name__ + "." + __qualname__)

    def __init__(self):
        super().__init__()
        self.actor_dir = os.path.dirname( os.path.realpath( __file__ ) )



    # {{ "".center(80, '=') }}
    # {{ " ACTOR METHODS ".center(80, '=') }}
    # {{ "".center(80, '=') }}

    # {{ "".center(80, '-') }}
    # {{ " INITIALIZE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.init_parameters
    @ActorBaseClass.use_sandbox
    def initialize(self, runtime_settings: RuntimeSettings = None, code_parameters: CodeParameters = None) -> None:
        """
        The method performs initialisation actions

        Args:
            runtime_settings (RuntimeSettings, optional): property tells the actor how native code should
            code_parameters (CodeParameters, optional): physics model parameters
        """
        super().initialize(runtime_settings, code_parameters)
    {%  if code_description.implementation.programming_language and code_description.implementation.subroutines.init %}
        Runner.get_runner(self).call_initialize()
    {%  endif %}
        ...

    # {{ "".center(80, '-') }}
    # {{ " RUN ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def run(self, {%- for argument in code_description.arguments if argument.intent == 'IN' -%}
                      {{ argument.name }},
                  {%- endfor -%}):
        """
        The main (aka 'step', 'run') method. Could be called in a loop.

        Args:
        {% for argument in code_description.arguments if argument.intent == 'IN' %}
            {{ argument.name }} - input IDS of type '{{ argument.type }}'
        {% endfor %}

        Returns:
        {% for argument in code_description.arguments if argument.intent == 'OUT' %}
            {{ argument.name }} - output IDS of type '{{ argument.type }}'
        {% endfor %}
        """
        {%  if code_description.implementation.programming_language and code_description.implementation.subroutines.main %}
        args = list(locals().values())[1:]
        out = Runner.get_runner(self).call_main(*args)
        return out
        {%  endif %}
        ...

    # {{ "".center(80, '-') }}
    # {{ " FINALIZE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.remove_sandbox
    @ActorBaseClass.use_sandbox
    def finalize(self) -> None:
        """
        The method is used to perform finalisation actions (clean up the environment etc).
        """
    {%  if code_description.implementation.programming_language and code_description.implementation.subroutines.finalize %}
        Runner.get_runner(self).call_finalize()
    {%  endif %}
        ...

    # {{ "".center(80, '-') }}
    # {{ " GET_STATE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def get_state(self) -> str:
        """
        A method returning information about internal model state

        Returns:
              An internal state of the code as a string. The iWrap gives a full flexibility to the code developer
              concerning format and content of state description.  It is a kind of a ‘black box’ returned
              from get_state and passed to set_state method during restart, so the only requirement is that
              information returned by get_state is understandable to set_state.

        """
    {%  if code_description.implementation.programming_language and code_description.implementation.subroutines.get_state %}
        state = Runner.get_runner(self).call_get_state()
        return state
    {%  endif %}
        ...

    # {{ "".center(80, '-') }}
    # {{ " SET_STATE ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def set_state(self, state: str) -> None:
        """
        A method restoring internal state of the model.

        Args:
            state (str) -  An internal state of the code as a string returned by a call of `get_state`
        """
{%  if code_description.implementation.programming_language and code_description.implementation.subroutines.set_state %}
        Runner.get_runner(self).call_set_state(state)
    {%  endif %}
        ...

    # {{ "".center(80, '-') }}
    # {{ " GET_TIMESTAMP ".center(80) }}
    # {{ "".center(80, '-') }}
    @ActorBaseClass.use_sandbox
    def get_timestamp(self) -> float:
        """
        The method allows to obtain currently computed physical time. Such information can help support consistent
        physical time handling throughout the coupled simulation

        Returns:
            timestamp (float): currently computed physical time
        """
    {%  if code_description.implementation.programming_language and code_description.implementation.subroutines.get_timestamp %}
        timestamp = Runner.get_runner(self).call_get_timestamp()
        return timestamp
    {%  endif %}
        ...
