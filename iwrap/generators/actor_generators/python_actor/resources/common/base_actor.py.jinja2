import os
import logging
import sys

from . import actor_info
from .code_parameters import CodeParameters
from .definitions import Argument
from .runtime_settings import RuntimeSettings, DebugMode, RunMode
from .definitions import Actor
from .sandbox import Sandbox


class ActorBaseClass(Actor):
    # Class logger
    __logger = logging.getLogger(__name__ + "." + __qualname__)

    __instance_index = 0

    # Provenance info
    actor_description = actor_info.ACTOR_DESCRIPTION
    code_description = actor_info.CODE_DESCRIPTION
    build_info = actor_info.BUILD_INFO

    # {{ "DECORATORS".center(80, '=') }}

    @staticmethod
    def init_parameters(func):
        def decorator_actions(self,  *args, **kwargs):
            if self.__code_parameters:
                code_parameters = kwargs.get('code_parameters')
                if code_parameters:
                    self.__code_parameters = code_parameters

                self.__code_parameters.initialize()

            value = func(self,  *args, **kwargs )

            return value

        return decorator_actions

    @staticmethod
    def use_sandbox(func):
        def decorator_actions(self,  *args, **kwargs):

            if self.sandbox:
                self.sandbox.jump_in()
            value = func(self,  *args, **kwargs )

            if self.sandbox:
                self.sandbox.jump_out()

            return value

        return decorator_actions

    @staticmethod
    def remove_sandbox(func):
        def decorator_actions(self,  *args, **kwargs):

            value = func(self,  *args, **kwargs )

            if self.sandbox:
                self.sandbox.remove()

            return value

        return decorator_actions

    # {{ "".center(80, '=') }}

    @property
    def unique_id(self):
        class_name = self.__class__.__name__
        idx = self.__instance_index
        pid = os.getpid()
        uid = f'{class_name}_{idx}#{pid}'
        return uid

    def __new__(cls):
        new_object = object.__new__( cls )
        cls.__instance_index += 1
        return new_object

    def get_runtime_settings(self) -> RuntimeSettings:
        return self.__runtime_settings

    def get_code_parameters(self) -> CodeParameters:
        return self.__code_parameters

    def __init__(self):
        self.output_stream = sys.stdout
        self.is_mpi_code = False
        self.__runtime_settings: RuntimeSettings = RuntimeSettings()
        self.sandbox: Sandbox =  Sandbox(self)
        self.arguments = []
        self.is_standalone = False
        self.__code_parameters: CodeParameters = None
        self.name = self.__class__.__name__
        self.__initialized = False

        self.data_type = '{{code_description.implementation.data_type | lower}}'
        self.native_language = '{{code_description.implementation.programming_language | lower}}'
        self.is_mpi_code = {% if not code_description.settings.mpi_compiler_cmd or code_description.settings.mpi_compiler_cmd == 'None' %} False {% else %} True  {% endif %}

        {% if code_description.implementation.code_parameters.parameters and code_description.implementation.code_parameters.schema %}
        # Static code parameters
        default_parameters_file = '{{code_description.implementation.code_parameters.parameters | basename}}'
        schema_file = '{{code_description.implementation.code_parameters.schema | basename}}'
        self.__code_parameters = CodeParameters( default_parameters_file, schema_file )
        {% endif %}

        self.sandbox_default_dir = '{{ platform_settings.directories.sandbox_dir }}'

        {% if code_description.settings.mpi_compiler_cmd %}
        # setting MPI parameters
        self.__runtime_settings.mpi = RuntimeSettings.MPISettings()
        self.__runtime_settings.mpi._default_runner = '{{ platform_settings.mpi_jobs.runner  or "" }}'
        self.__runtime_settings.mpi._default_options = '{{ platform_settings.mpi_jobs.options or "" }}'
        {% endif %}

        # setting BATCH parameters
        self.__runtime_settings.batch._default_runner = '{{ platform_settings.batch_jobs.runner  or "" }}'
        self.__runtime_settings.batch._default_options = '{{ platform_settings.batch_jobs.options  or "" }}'

        # setting DEBUGGER parameters
        self.__runtime_settings.debugger._default_cmd = '{{ platform_settings.debugger.cmd   or "" }}'
        self.__runtime_settings.debugger._default_attach_cmd = "{{ platform_settings.debugger.attach_cmd  or "" }}"

    def logging_config(self, level, stream=None):
        """
        Configures logging of information on various levels and allows
        users to decide which level of logging to use for each actor
        individually.
        Args:
            level (str | int): Logging severity below which messages are
                not logged. Must be one of: debug, info, warning, error,
                critical (case-insensitive). Required.
            stream: Defines a stream to which logging output will be sent:
                it could be to streams such as sys.stdout, sys.stderr or
                any file-like object (any object which supports write()
                method). Optional, defaults to stderr.
        Returns:
            logging.Logger: A configured logger with a name of an actor.
            Usage: <logger>.debug("message"), <logger>.error("message"), etc.
        """
        actor_package_logger = logging.getLogger(__name__.split('.')[0])
        try:
            actor_package_logger.setLevel(
                level.strip().upper() if isinstance(level, str) else level)
        except ValueError:
            print(f'ERROR: Incorrect logging level: "{level}". Logging disabled. Available logging levels: debug, info, warning, error, critical (case-insensitive).')
        else:
            handler = logging.StreamHandler(stream)
            handler.setFormatter(logging.Formatter(
                '%(asctime)s [%(name)s] %(levelname)s: %(message)s'))
            actor_package_logger.addHandler(handler)
            return actor_package_logger

    def is_standalone_run(self):
        if self.is_mpi_code:
            return True

        if self.__runtime_settings.debug_mode == DebugMode.STANDALONE:
            return True

        if self.__runtime_settings.run_mode == RunMode.STANDALONE:
            return True

        if self.__runtime_settings.run_mode == RunMode.BATCH:
            return True

        return False

    # # #  Actor lifecycle methods # # #

    def initialize(self, runtime_settings: RuntimeSettings = None, code_parameters: CodeParameters = None):
        """
        Attributes:
            runtime_settings (RuntimeSettings): Path to a XML file with code parameters
            code_parameters (CodeParameters): Path to a XSD file with schema definition for code parameters file
        """
        self.__initialized = True

        if runtime_settings:
            self.__runtime_settings = runtime_settings

        self.is_standalone = self.is_standalone_run()
        self.sandbox.initialize()

    def __call__(self, *args):
        if not self.__initialized:
            message = 'Actor was not initialized. Always remember to initialize actor by explicitly calling actor.initialize() method'
            raise RuntimeError(message)
        return self.run( *args )

    def run(self, *args):
        ...

    def finalize(self):
        ...

    def get_state(self) -> str:
        ...

    def set_state(self, state: str) -> None:
        ...

    def get_timestamp(self) -> float:
        ...
